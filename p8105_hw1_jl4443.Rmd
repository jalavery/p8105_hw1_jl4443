---
title: "P8105 Homework 1"
author: "Jessica Lavery"
date: "9/15/2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
```

# Problem 1
```{r setup_df_prob1}
df <- tibble(
  norm_samp = rnorm(8),
  sample_ge0 = norm_samp >= 0, 
  character_vector = c("one", "two", "three", "four", "five", "six", "seven", "eight"),
  factor_vector = factor(x = c("a", "b", "c", "a", "a", "b", "c", "c"), levels = c("a", "b", "c"))
)

#try to take the mean of each variable
mean(pull(df, norm_samp))

mean(pull(df, sample_ge0))

mean(pull(df, character_vector)) #error: argument is not numeric or logical: returning NA[1] NA

mean(pull(df, factor_vector)) #error: argument is not numeric or logical: returning NA[1] NA
```

```{r coerce_numeric, results = FALSE}
mean(pull(df, as.numeric(sample_ge0)))

mean(pull(df, as.numeric(character_vector)))

mean(pull(df, as.numeric(factor_vector)))
```

The logical variable is converted to a numeric variable with 0's (FALSE) and 1's (TRUE), and the mean is able to be computed using the `as.numeric` function. However, the character and factor variables still produce an error.

```{r }
#convert the logical vector to numeric and multiply the random sample by the result.
as.numeric(pull(df,sample_ge0)) * pull(df, norm_samp)

#convert the logical vector to a factor, and multiply the random sample by the result.
as.factor(pull(df,sample_ge0)) * pull(df, norm_samp)

#convert the logical vector to a factor and then convert the result to numeric, and multiply the random sample by the result
as.numeric(as.factor(pull(df,sample_ge0))) * pull(df, norm_samp)
```

# Problem 2
```{r setup_df_prob2}
df2 <- tibble(
  x = rnorm(500),
  y = rnorm(500),
  x_plus_y_gt1_logical = (x + y > 1),
  x_plus_y_gt1_numeric = as.numeric(x_plus_y_gt1_logical),
  x_plus_y_gt1_factor = as.factor(x_plus_y_gt1_logical)
)
```

The dataset includes `r ncol(df2)` variables with `r nrow(df2)` observations. Variable x has mean `r mean(pull(df2, x))` and standard deviation `r sd(pull(df2, x))`. From the random samples, `r 100*mean(pull(df2, x_plus_y_gt1_numeric))`% of instances have x + y > 1. 

```{r plot_df2_logical}
ggplot(data = df2, aes(x = x, y = y, color = x_plus_y_gt1_logical)) +
  geom_point()

#export to project directory
ggsave(filename = "hw1_figure1_logical_color_scale.png")
```

```{r plot_df2_numeric}
ggplot(data = df2, aes(x = x, y = y, color = x_plus_y_gt1_numeric)) +
  geom_point()
```

Using a numeric variable to indicate the color of the scatterplot results in a color gradient spanning the range of the variable, despite the fact that there are no instances of the variable having a value between 0 and 1. 

```{r plot_df2_factor}
ggplot(data = df2, aes(x = x, y = y, color = x_plus_y_gt1_factor)) +
  geom_point()
```

Using a factor variable to determine the color of the points on the scatterplot is similar to using the logical variable to indicate the color. 